OCP3 MVC OOP PHP Project<br />
<br /><br />
PHOC Framework: XSLT, Annotation and Unit Test Engine<br /><br /><br />
PHOC Framework<br />
<br />
1. General IoC Framework<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Annotation-Oriented<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Signal Dispatch<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Concurrency Support?<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Standard Object-Orientation + Functional Style<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Statically Typed<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Virtual Filesystem<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Data Caching<br />
<br />
2. MVC Web Framework<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Static Annotation-Based Router<br />
&nbsp;&nbsp;&nbsp;&nbsp;- XSLT-Based Templating Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;- Durable Instance (Logic Outliving Request Lifetime)<br />
<br />
<br />
Cache and Instance Manipulations:<br />
- Disable/Enable Developer Mode (clears and enables/disables cache)<br />
- Reboot Instance (clears cache, clears durable objects)<br />
- Reload Configuration (clears configuration cache)<br />
- Clear Cache (clears cache)<br />
<br /><br /><br /><br />
Durable Objects:<br />
Classical PHP program execution is limited to a HTTP request.<br />
Persistent data need to be stored in cache, databases or sessions, but they all need special handles.<br />
PHOC offers a nearly native way of accessing persistent data: the Application Instance.<br />
The Application Instance is half-way between sessions and databases: it is the lifetime of the program's deployment.<br />
At its core, the Application Instance is a group of objects stored outside the program, and injected into variables, by the framework.<br />
These objects are called Durable Objects and are fields annotated <code>@Durable</code>.<br />
The <code>@Durable</code> fields are initialized from cached objects during program initialization, and their value is saved during end of life, thus, they are direct handles to persistent data.<br />
<br />Ex:
<pre>
use PHOC\Annotations\Durable;
use PHOC\Annotations\Entry;

class Program
{
    /** @Durable */
    static private $Value;
    
    /** @Entry */
    static public function Main()
    {
        if(isset($_GET["Value"]))
        {
            self::$Value->Set($_GET["Value"]);
            header("Location: ./");
            exit;
        }
        
        echo(self::$Value);
    }
}
</pre>
This program outputs the value of <code>Program::$Value</code>, which is annotated <code>@Durable</code>, therefore, after one access with the parameter <code>?Value=42</code>, <strong>42</strong> will be printed.<br />
As shown, one must use the <code>Set</code> and <code>Get</code> methods to access the object without rebinding the handle, though the magic <code>__toString</code> method is implemented for seamless integration.<br />
Sadly, as PHP does not natively support long-living objects, <code>@Durable</code> objects must live in a cache, database or in the filesystem, all of them involving costly operations (cache extensions should be used when possible, but that is outside the scope of the language.)<br />
The objects are said to live in the Instance Image.<br />
The Instance Image is a piece of cached serialized data, retrieved at startup and flushed at exit.<br />
There is one exception to this: when the program exits, no matter why, if one of the PHP shutdown functions fails before reaching the savepoint, then the current state is effectively lost, and future processes will fallback to a prior snapshot.<br />
<br />
Durable Objects are set to NULL by default, but they can be initialized to any arbitrary values as long as it is serializable, with the annotation only parameter.<br />
Ex:
<pre>
class Foo
{
    /** @Durable(42) */
    static private $Value;
    
    /** @Entry */
    static public function Main()
    {
        echo(self::$Value); //42
    }
}
</pre>
Object initialization differs from handle initialization.<br />
Durable objects are initialized each time a new Application Instance is started, that is, when no Instance Image is located, or when the Developer Mode is on.<br />
Handle initialization, however, is the process of binding a variable to a Durable Object. This happens during class initialization.<br />
Class initialization follows this order:<br />
1. Classic PHP fields initialization (only works with constant expressions).<br />
2. If there aren't any Instance Images, then the durable objects are initialized either to NULL or to any expressions.<br />
&nbsp;&nbsp;&nbsp;Otherwise, the durable objects' fields are simply set to objects handling them.<br />
3. If there aren't any Instance Images and an <code>@AppInit</code> function is present, it is called.<br />
4. If an <code>@ClassInit</code> function is present, it is called.<br />
<br />
Following this order, and assuming a well-formed program without interruption, there should be only one consistent Instance Image, <code>@Durable</code> objects should be initialized, and <code>@AppInit</code> functions should be called, only one time during the whole application's lifetime.<br />
Notably, it could be noted that the annotation system makes great use of the Application Instance by storing the metadata of the whole program in it, and so, removes the use of RTTI and parsing operations as well as reduces decision-making operations for the framework.<br />

<br /><br /><br /><br />
